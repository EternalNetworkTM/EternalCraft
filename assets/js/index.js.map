{"version":3,"sources":["index.js"],"names":["LOADING_OVERLAY_FADE_DURATION","ANIMATION_CLASSES","HEADER_IMAGE_OPACITY","HEADER_IMAGE_TRANSLATE_PERCENT","HEADER_IMAGE_SCALE_FACTOR","setupAnimations","animationObserver","IntersectionObserver","entries","i","length","entry","isIntersecting","target","classList","remove","unobserve","document","querySelectorAll","forEach","element","observe","setupHeaderImageParallax","header","querySelector","headerImage","scrollHandler","headerRect","getBoundingClientRect","percentVisible","Math","max","height","top","style","opacity","translateY","scale","transform","headerImageEntry","addEventListener","removeEventListener","setupLanguageMenu","languageButton","languageMenu","toggle","ruleObjects","setupRules","ruleEntries","children","rule","body","label","ruleObject","icons","push","toggleRule","otherRuleObject","otherRule","contains","collapseRule","scrollHeight","j","doneLoading","documentElement","loadingOverlay","animation","animate","duration","easing","fill","onAnimationEnd","add","window"],"mappings":"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","sourcesContent":["'use strict';\n\nconst LOADING_OVERLAY_FADE_DURATION = 250;\n\nconst ANIMATION_CLASSES = ['animation-fade-in', 'animation-slide-down', 'animation-zoom-out'];\n\nconst HEADER_IMAGE_OPACITY = 0.4;\nconst HEADER_IMAGE_TRANSLATE_PERCENT = 50;\nconst HEADER_IMAGE_SCALE_FACTOR = 0.2;\n\nfunction setupAnimations() {\n    const animationObserver = new IntersectionObserver((entries) => {\n        for (let i = 0; i < entries.length; i++) {\n            const entry = entries[i];\n            if (entry.isIntersecting) {\n                entry.target.classList.remove(...ANIMATION_CLASSES);\n                animationObserver.unobserve(entry.target);\n            }\n        }\n    });\n    const animatedElements = document.querySelectorAll('.animation');\n    animatedElements.forEach((element) => animationObserver.observe(element));\n}\n\nfunction setupHeaderImageParallax() {\n    const header = document.querySelector('header');\n    const headerImage = document.querySelector('.background-image');\n\n    function scrollHandler() {\n        const headerRect = header.getBoundingClientRect();\n        const percentVisible = Math.max((headerRect.height + headerRect.top) / headerRect.height, 0);\n        headerImage.style.opacity = HEADER_IMAGE_OPACITY * percentVisible;\n        const translateY = (1 - percentVisible) * HEADER_IMAGE_TRANSLATE_PERCENT;\n        const scale = 1 + (1 - percentVisible) * HEADER_IMAGE_SCALE_FACTOR;\n        headerImage.style.transform = `translateY(${translateY}%) scale(${scale})`;\n    }\n\n    const headerObserver = new IntersectionObserver((entries) => {\n        const headerImageEntry = entries[0];\n        if (headerImageEntry && headerImageEntry.isIntersecting) {\n            document.addEventListener('scroll', scrollHandler);\n        } else {\n            document.removeEventListener('scroll', scrollHandler);\n        }\n    });\n    headerObserver.observe(header);\n\n    scrollHandler();\n}\n\nfunction setupLanguageMenu() {\n    const languageButton = document.querySelector('.language-button');\n    const languageMenu = document.querySelector('.language-menu');\n\n    languageButton.addEventListener('click', () => {\n        languageMenu.classList.toggle('hidden');\n    });\n}\n\nconst ruleObjects = [];\n\nfunction setupRules() {\n    const ruleEntries = document.querySelector('.rules-container').children;\n\n    for (let i = 0; i < ruleEntries.length; i++) {\n        const rule = ruleEntries[i];\n        const body = rule.querySelector('.body');\n\n        if (!body) {\n            continue;\n        }\n\n        const label = rule.querySelector('.label');\n        const icons = label.querySelectorAll('.icon');\n\n        const ruleObject = {\n            element: rule,\n            icons: icons,\n            body: body\n        };\n        ruleObjects.push(ruleObject);\n        rule.addEventListener('click', () => toggleRule(ruleObject));\n    }\n}\n\nfunction toggleRule(ruleObject) {\n    for (let i = 0; i < ruleObjects.length; i++) {\n        const otherRuleObject = ruleObjects[i];\n        const otherRule = otherRuleObject.element;\n        if (otherRule !== ruleObject.element && otherRule.classList.contains('expanded')) {\n            collapseRule(otherRuleObject);\n        }\n    }\n\n    if (ruleObject.element.classList.contains('expanded')) {\n        ruleObject.body.style.height = '0px';\n    } else {\n        ruleObject.body.style.height = `${ruleObject.body.scrollHeight}px`;\n    }\n    ruleObject.element.classList.toggle('expanded');\n    for (let j = 0; j < ruleObject.icons.length; j++) {\n        ruleObject.icons[j].classList.toggle('hidden');\n    }\n}\n\nfunction collapseRule(ruleObject) {\n    ruleObject.body.style.height = '0px';\n    ruleObject.element.classList.remove('expanded');\n    for (let i = 0; i < ruleObject.icons.length; i++) {\n        ruleObject.icons[i].classList.toggle('hidden');\n    }\n}\n\nfunction doneLoading() {\n    document.documentElement.classList.remove('loading');\n\n    const loadingOverlay = document.querySelector('.loading-overlay');\n    const animation = loadingOverlay.animate(\n        [{ opacity: 1 }, { opacity: 0 }],\n        {\n            duration: LOADING_OVERLAY_FADE_DURATION,\n            easing: 'ease',\n            fill: 'forwards'\n        }\n    );\n\n    function onAnimationEnd() {\n        loadingOverlay.classList.add('hidden');\n    }\n\n    animation.addEventListener('finish', onAnimationEnd);\n    animation.addEventListener('cancel', onAnimationEnd);\n}\n\nwindow.addEventListener('load', () => {\n    setupAnimations();\n    setupHeaderImageParallax();\n    setupLanguageMenu();\n    setupRules();\n    doneLoading();\n});\n"],"file":"index.js"}